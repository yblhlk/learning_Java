1. 饿汉式单例
> a. 创建一个私有的本类对象<br> (要静态化，才能被静态方法直接使用，因为获取方法必须是静态的所以这个对象也必须是静态的。)<br>
> b. 私有化构造器 <br>
> c. 提供一个`静态方法`供外界访问对象（静态方法，才能不通过对象来使用）

2. 懒汉式单例
> 懒汉模式有两点要考虑的地方：
> * 线程安全，所以要加锁
> * 数据的可见性，所以要加volatile.

3. 双重检索的单例
> * 单纯的饿汉在多线程情况下效率比较低，所以使用双重检索来对饿汉进行优化，好处是不需要每次都申请锁。
> * 还要加上volatile保证对象的可见性，不然可能出现线程空间没有同步到主内存空间的情况。

4. 静态内部类实现单例
> * 类只加载一次，所以其天然是线程安全的。
> * 是使用静态内部类对饿汉式单例的一种优化。（在安全性方面）

5. 枚举式的单例
> * 为了防止通过反射来突破限制(是无法通过放射来获取enum类的构造函数的（Instance()遇到enum类会直接抛异常）)

> 供外界获取单例对象的方法，最好是静态的，因为静态方法才能让外界直接通过类来调用，而不需要创建对象。
> * 静态化的作用：1.让成员能通过类直接访问，而不需要创建对象来调用。 2.让所有对象共享该属性。
> * 静态变量和非静态变量最大的区别在于：静态变量能通过类直接访问。

6. 单例模式主要可以分成两类：
> * 饿汉式单例 -> 静态内部类实现单例（巧妙利用类的加载机制） -> 枚举式的单例（安全性：防止反射突破封装）
> * 懒汉式单例 -> 双重检索的单例（保证线程安全）

7. 饿汉式单例和懒汉式单例的对比
> 懒汉式更节约内存资源，因为不一定会被调用。
> 饿汉式性能更高，因为懒汉式需要判断是否为null，而且还要加锁考虑线程同步。
