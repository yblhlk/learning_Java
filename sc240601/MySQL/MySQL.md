## 1. 什么是数据库？

> 从宏观上来讲，数据库分为三个部分：
>
> * 客户端：一个与用户交互，接收用户指令的程序。
> * 服务端：一个用来管理数据库文件的程序，它会响应客户端的指令，对相应的数据库文件进行操作。
> * 数据库文件： 保存数据的数据库文件或文件的集合。
>
> 总结一下：从宏观上来讲，__数据库就是管理数据库文件的程序 + 保存数据的数据库文件的集合。__
>
> 从狭义上来讲，保存数据的数据库文件或文件的集合也能被叫做数据库。
>
> <hr>
> 为什么需要数据库？ -- 如果是单纯的序列化来存储数据，不适合大量的数据存储。
>
> ![image-20240708141257555](D:\Pictures\MySQL\image-20240708141257555.png)

## 2.数据库分类

![image-20240708141352338](D:\Pictures\MySQL\image-20240708141352338.png)

### 2.1 关系型数据库

![image-20240708141552569](D:\Pictures\MySQL\image-20240708141552569.png)

> ==感悟==：
>
> 对象中的引用类型成员，无法通过一格来描述，可以再开一张表，让字段和表中一行联系起来即可：
>
> ![image-20240708142053106](D:\Pictures\MySQL\image-20240708142053106.png)

<img src="D:\AppData\Typora\typora-user-images\image-20240708142451355.png" alt="image-20240708142451355" style="zoom:50%;" />

### 2.2 非关系型数据库

![image-20240708142805546](D:\Pictures\MySQL\image-20240708142805546.png)

<img src="D:\Pictures\MySQL\image-20240708143018558.png" alt="image-20240708143018558" style="zoom:50%;" />

![image-20240708143155550](D:\Pictures\MySQL\image-20240708143155550.png)

## 3. 安装MySQL

![image-20240708144252154](D:\Pictures\MySQL\image-20240708144252154.png)

![image-20240708144235889](D:\Pictures\MySQL\image-20240708144235889.png)

![image-20240708145503967](D:\Pictures\MySQL\image-20240708145503967.png)

![image-20240708145713649](D:\Pictures\MySQL\image-20240708145713649.png)

![image-20240708144614293](D:\Pictures\MySQL\image-20240708144451726.png)

> 拓展：
>
> 环境变量中的__系统变量__和__用户变量__：
>
> 系统变量是这台电脑上的，用户变量是属于这个Windows账户的。
>
> ![image-20240708145243077](D:\Pictures\MySQL\image-20240708145243077.png)

> 拓展：
>
> 以管理员权限打开命令提示符窗口
>
> ![image-20240708150230383](D:\Pictures\MySQL\image-20240708150230383.png)
>
> 
>
> ![image-20240708150346432](D:\Pictures\MySQL\image-20240708150346432.png)

![image-20240708154332360](D:\Pictures\MySQL\image-20240708154332360.png)

> 在Navicat中新建数据库时，一定要更改编码，不然查询的时候会乱码（mysql8 选择 utf8-mb4)
>
> ![image-20240708154546535](D:\Pictures\MySQL\image-20240708154546535.png)
>
> ![image-20240708175851361](D:\Pictures\MySQL\image-20240708175851361.png)



![image-20240708155848804](D:\Pictures\MySQL\image-20240708155848804.png)



## 4. MySQL

![image-20240708160321901](D:\Pictures\MySQL\image-20240708160321901.png)

![image-20240715115201990](D:\Pictures\MySQL\MySQL的优势.png)

## 5. SQL语句的分类

* DDL ：数据定义语言，用于创建和删除数据库中的对象（数据库，表，视图，索引，触发器，函数……），不支持回滚
  如：create(创建) ==drop(删除)== alter(修改) truncate(截断表)
* DML ：数据操作语言，用于操作表中的数据。
  如：insert(插入) delete(删除) updata(修改)
* DQL ：数据查询语言，用于查询表中的数据
  如：select -- 最常用，最难用
* DCL ：数据控制语言，用来控制数据库组件的属性，权限等
  如：grant(授权) revoke(撤销权限)
* TCL ：事务控制语言，用来提交或回滚事务
  如：commit(提交) rollback(回滚)

![image-20240708161551432](D:\Pictures\MySQL\image-20240708161551432.png)

![image-20240708161946313](D:\Pictures\MySQL\image-20240708161946313.png)

![image-20240708162246920](D:\Pictures\MySQL\image-20240708162246920.png)

### 5.1 DDL

#### a. create命令创建表：

```sql
-- 语法规则：[]表示可有可无
-- if not exists : 判断表是否存在。
-- `` : 防止和关键字冲突。
-- [desc 表名] ：查看表的详细信息。
-- [show create table 表名 [\G]] ：查看创建表的语句。
create table [if not exists] `表名` (
 字段名1  数据类型  [约束] [索引] [注释],
 字段名2  数据类型  [约束] [索引] [注释],
 ……
 字段名n  数据类型  [约束] [索引] [注释] --最后一句不用加","
)[表类型][表字符集][注释];

-- 扩展：使用as用查询结果建表
-- 写一个sql语句，删除重复记录，只保留有效记录。
create table t1 (
  name char(20) comment "姓名",
  tel int
);
insert into t1 values ("张三", "60121"),("张三", "60121"),("张三", "60121"),
("张三", "11111"),("李四", "60125"),("王二", "60126");
-- 创建一张表，只存储原表去重后的数据
create table t2 AS
select distinct name, tel from t1; 
-- 或查询视图
```

> 注：创建表的关键字是table， 字段和字段之间通过","间隔，结束语句通过";"

> 保存查询：
>
> 1. Ctrl + q 打开一个新的查询窗口
> 2. Ctrl + s 保存查询
>    ![image-20240708163625640](D:\Pictures\MySQL\image-20240708163625640.png)
> 3. 在数据库的查询中找到，没有就右击，然后选择刷新
>
> ![image-20240708164401754](D:\Pictures\MySQL\image-20240708164401754.png)

> Navicat 更改字体大小和颜色：
>
> 工具 -> 选项 -> 字体/颜色
>
> ![image-20240708164108746](D:\Pictures\MySQL\image-20240708164108746.png)
>
> ==重启后生效。==

> ![image-20240708164618170](D:\Pictures\MySQL\image-20240708164618170.png)
>
> ![image-20240708164714803](D:\Pictures\MySQL\image-20240708164714803.png)



> 如何查看表注释？
>
> ![image-20240708171023688](D:\Pictures\MySQL\image-20240708171023688.png)

#### b. alter修改表

```sql
-- 修改表名
alter table oldname rename newname;
-- 添加字段
alter table 表名 add 字段名 类型;
-- 修改字段
alter table 表名 change 原字段名 新字段名 类型;
-- 删除字段
alter table 表名 drop 字段名;
```

![image-20240708171544604](D:\Pictures\MySQL\image-20240708171544604.png)

#### c. drop命令删除表

```sql
drop table 表名;
```

### 5.2 DML

#### a. insert命令新增数据

```sql
-- 语法1：选择字段插入（字段可乱序，但必须和后面的值一一对应）
insert into 表名 (字段名2, 字段名5，字段1) values (值2,值5,值1);

-- 语法2：全字段插入（表里有几个字段，要写几个数据，且要一一对应）
insert into 表名 values (值1,值2,值3……);

-- 语法3：批量插入（value后面接多组具体值）
insert into 表名 (字段名2, 字段名5，字段1) values (值2,值5,值1),(值22,值55,值11),……;
insert into 表名 values (值1,值2,值3……),(值11,值22,值33……),……;

-- 语法4：借助select特点实现批量插入 (以下是批量新增三条数据的例子)
insert into 表名 select 值1,值2,值3……,值n union
				select 值1,值2,值3……,值n union
				select 值1,值2,值3……,值n ;
```

> `dual`：mysql和Oracle 中的虚表，mysql 可略写
>
> ![image-20240708174407038](D:\Pictures\MySQL\image-20240708174407038.png)

#### b. update语句

```sql
-- 语法：(注意update后面没有from)
update 表名 set 字段=值1,字段2=值2,…… where 条件;
注：where后面的条件 必须加，否则全表更新
条件目的：计算限制数据集 比如：> < = 来进行控制。
```

#### c. delete语句

```sql
-- 语法（注意from不要写成form表单）
delete from 表名 where 条件
注：where后面一定要添加条件 否则全表删除
```

## 6. MySQL的数据类型 ==面试题==

* 数值类型

|   类型   |  大小  |      介绍      |
| :------: | :----: | :------------: |
| smallint | 2字节  |     小整型     |
|   int    | 4字节  |      整型      |
|  bigint  | 8字节  |     大整型     |
|  float   | 4字节  |     单精度     |
|  double  | 8字节  |     双精度     |
| decimal  | 31字节 | 精确数值浮点型 |

> * double：是一种双精度浮点型，可以存储大约15位有效数字。占8个字节，到达一定精度后会进行四舍五入。
> * decimal：是精确数值类型，不允许误差，可以精确保存小数位，不能进行四舍五入。可以存储大约65位有效数字。
>
> ==注：浮点型的使用都是类似的，float(6,2)4个整数，2个小数，deouble(6,2)，decimal(6,2)也一样。==

* 字符串类型

> ==注：mysql没有字符，只有字符串类型。==

|     类型      |                     大小                     |    介绍    |
| :-----------: | :------------------------------------------: | :--------: |
|     char      |                 255个`字符`                  | 定长字符串 |
|    varchar    |   65535字节<br>(能存几个字符要看编码方法)    | 变长字符串 |
| text/longtext |           65535`字符`/longtext更长           | 长文本类型 |
|     blob      | 2^16-1个字节<br>（存放二进制文件，如图片等） | 二进制类型 |

> MySQL中char类型和varchar类型的区别：
>
> char一旦创建就不能改变其大小。上限为255个字符。
>
> varchar会根据内容来决定占用的空间，存储的内容变大，空间也变大。上限为65535个字节。
>
> ![image-20240709155007187](D:\Pictures\MySQL中char类型和varchar类型的区别.png)

* 日期类型

|   类型    |        格式         |    介绍    |
| :-------: | :-----------------: | :--------: |
|   date    |     YYYY-MM-DD      |   日期值   |
|   time    |      HH:mm:ss       |   时间值   |
|   year    |        YYYY         |   年份值   |
| timestamp | YYYY-MM-DD HH:mm:ss |   时间戳   |
| datetime  | YYYY-MM-DD HH:mm:ss | 日期时间值 |

> timestamp和datetime的区别：
>
> * ==容量不同：timestamp占4个字节，datetime在mysql5.6后占5个字节之前是8个字节。==
> * 存储不同：==timestamp存储的值转换成UTC的时间再进行存入。==datetime不会转换，给什么存什么。
> * 存储null：timestamp在mysql8之前，如果存储null自动转换为now()，datetime不会，给什么存什么。
> * 存储now()：timestamp可能与当前时间不一致，因为他会把当前时间转化为UTC来存储；但datetime不会转换，和当前时间是一致的。（当UTC（格林尼治标准时间）为00:00时，东八区的标准时间为08:00。）

## 7. DQL

### 1. 基础查询语句

```sql
-- 基本语法：[]可有可无，必须按下面的顺序来加，如group by必须在where后面。
select 查询的字段，字段2，…… 
from 表名或者视图名
[where 分组前的条件]
[group by 分组的字段]
[having 分组后的条件]
[order by 排序的字段 desc/asc] -- 对查询结果进行排序
[limit [[起始偏移量,]函数] //从3下标开始查5条数据
```

> 别名：进行复杂查询时，可能会涉及到多张表重名的情况，很可能出现 字段 和 表 重复的问题
> -- 可以给这些重名的内容 添加一个临时的名称，可以减少代码复杂度
> -- 语法：字段名 as 别名 或 表名 as 别名
> -- 注：as可以省略 别名是可以不加引号的

> ==查询语句中各关键字的执行顺序：==
> from > where > group by > having > select > order by > limit

#### a. where子句 (精确查询)

对查询结果做第一次筛选

```sql
-- 1. 查询范围
select * from 表 where 字段>60;

-- 2. MySQL中的逻辑运算符是 `and` `or` `not`
select * from 表 where 字段>60 and 字段<80;

-- between 是闭区间，包括左右边界
select * from 表 where 字段 between 60 and 80;
select * from 表 where 字段 not between 60 and 80; -- 不包括60和80

-- 判断是否为null
select * from 表 where 字段 is null;

-- 筛选不等于 (!= 或 <>)
select * from 表 where 字段!=100;
select * from 表 where 字段<>100;

-- 筛选等于
-- 注意：MySQL中的等于是单个=。
select * from 表 where 字段=10;

-- 筛选等于多个值(=)
-- 简化版：in()函数等价于或者的意思
select * from 表 where 字段 in (10,20,50);
-- 等价于
select * from 表 where 字段=10 or 字段=20 or 字段=50);
```

#### b. like子句 （模糊查询）

> 如果对查询条件不明确，只知道部分内容，Mysql中可以使用模糊查询方式来实现它。

> 常见的模糊查询:
>
> ![image-20240709174744425](D:\Pictures\常见的模糊查询.png)
>
> * ___ : 长度为3的内容。
>
> select * from 表 where 字段 like "%a%";

#### c. rlike（正则表达式查询）

在MySQL中，`RLIKE` 是一个操作符，用于在字符串搜索中执行正则表达式匹配。它与 `REGEXP` 操作符是同义词，即两者在功能上完全相同，只是名称不同。使用 `RLIKE` 或 `REGEXP`，你可以在查询中搜索与指定正则表达式模式匹配的字符串。

> 示例:
> 假设我们有一个名为 `employees` 的表，其中有一个名为 `email` 的列，我们想要找出所有以 "john" 开头，后跟任意字符（包括0个字符），最终以 "@example.com" 结尾的电子邮件地址。
>
> ```sql
> SELECT email
> FROM employees
> WHERE email rlike '^john.*@example.com$';
> 
> -- 或者
> 
> SELECT email
> FROM employees
> WHERE email regexp '^john.*@example.com$';
> ```
>
> 这个查询会匹配所有形如 "john@example.com"、"john123@example.com" 等的电子邮件地址，但不会匹配 "johnny@example.com" 或 "john@example.net"，因为正则表达式模式要求以 "john" 开头并以 "@example.com" 结尾。

> 注意事项:
>
> - 正则表达式区分大小写，除非你使用了不区分大小写的模式（例如，在MySQL中，这通常意味着使用 `REGEXP_LIKE()` 函数与适当的模式标志，但请注意，`REGEXP_LIKE()` 是MySQL 8.0中引入的，并且不是所有MySQL版本都支持）。
> - 正则表达式可以非常复杂，允许你执行精确的文本匹配，包括字符类、量词、边界匹配等。
> - ==使用正则表达式可能会比使用简单的字符串函数（如 `LIKE`）更慢，因为正则表达式需要更复杂的处理。因此，在性能敏感的查询中，应谨慎使用正则表达式。==
> - MySQL的正则表达式语法与Perl兼容，但并非所有Perl正则表达式特性都在MySQL中受支持。请查阅MySQL的官方文档以获取有关支持的特性和语法的详细信息。

#### d. union子句

mysql中union用于`链接多个select语句的结果集`，最终合并为一个结果集。特点：如果这多个select语句的结果中有重复的数据，`会自动去重`。union all 不会去重。
并且使用union还可以实现数据库列转行。

```sql
-- 语法1：(会自动去重)
select 字段1，字段2 from 表
union
select 字段1，字段2 from 表

-- 语法2：(如果不想去重，使用union all)
select 字段1，字段2 from 表
union all
select 字段1，字段2 from 表
```

> 注：使用union合并时，查询结果中列的个数必须相同，和字段的类型没有关系。 

#### e. order by子句

数据库本身的顺序是无序的。
==order by 是对select的结果进行排序。其执行时间在select之后。==

![image-20240710114902124](D:\Pictures\MySQL\image-20240710114902124.png)

``` sql
-- 语法：
order by 字段 排序规则;
-- 排序规则：ASC升序（默认值）,DESC（降序）

-- 语法2：如果一个查询要按照两个字段来排序可以通过“,”来分隔
order by 字段1 排序规则, 字段2 排序规则;
```

#### f. limit 子句

limit是mysql中用于通过下标（索引值）来限定查询结果显示条数的一种方式，它后期也是实现数据分页的非常重要的途径。==limit 的下标从零开始。==

```sql
-- 语法：
limit [起始索引值,]查询的条数;

-- 例如：查询一张表 每页5条数据，查询第三页的所有数据
limit 10,5; //10表示从下标为10的第11条数据开始查询，查询5条
-- 比如：查询一张表的前10条数据
limit 0,10;
-- 等价于
limit 10;
```

## 8. MySQL约束

约束：是用于限定表中的数据，凡是不符合约束要求的数据，是无法插入到表中的，增加的表的准确性。

约束可以在建表时添加。也可以通过修改表来添加。

* 非空约束：`not null`   强制要求字段不能为空。

* ==默认约束==：`default`    保证字段一定有值，如果没有赋值，会被设置为默认值。（赋值为null也表示其有值，不会被设为默认值。）（全字段插入没有办法走默认值

* 唯一约束：`unique`   保证字段中的值是唯一的，但是值可为null。并且唯一约束 还会自动添加`唯一索引`

* 检查性约束：`check` 是用于给字段的数据做一些检查，看是否符合要求(如大于某个值)，但mysql8以后才会生效，mysql8之前语法能通过，但是没有效果。

* 主键约束：`primary key(pk)` 主键约束自带 唯一 和非空两种功能，`每张表只能有一个主键`，并且主键约束会自动添加一个`主键索引`

* ==外键约束==：`foreign key(fk)` 定义在具有父子关系的子表中，子表中的外键必须对应父表中的主键，父表中没有的值子表中的外键字段不能写。

  > (==前提：添加外键时，一定是先创建父表再创建子表，父表不存在，子表会创建失败。==)
  > ( 在删除时也不能先删除父表，再删除子表）
  >
  > ( 外键列可以为null，否则必须是父类主键已有数据）
  >
  > ( 外键和主键的数据类型必须相同）

  > 如何添加外键约束?
  >
  > 在建表末尾加上：foreign key (子表字段) references 父表名(父表主键)  （父表必须存在，且必须是主键）

> 父表和子表
>
> 子表中的数据是从父表中来的。
>
> ![image-20240710151309253](D:\Pictures\MySQL\父表和子表.png)

#### 设置自增

> `auto_increment`
>
> 在MySQL中，==不能给没有索引的列设置自增属性（AUTO_INCREMENT）==。自增属性要求该列必须是索引的一部分，这意味着它必须是主键或具有唯一约束的列。
>
> -- 4. 主键自增
> -- 主键设置了自增，就可以设置主键为null,表示走自增的意思。
> -- 只有数值类型(包括double)才能设置自增，自增只能设置在索引中
> -- 自增按最后一行数据来自增
>
> create table city (
> 	id int `auto_increment` comment "城市id",
> 	name varchar(100) comment "城市名",
> 	primary key(id)
> );

```sql
-- 1. 在创建表时添加约束
-- 要添加多个约束时，直接使用","进行分隔
create table person (
id int primary key comment "人类编号", -- 主键
name varchar(20) not null comment "姓名",
age int default 18 comment "年龄",
sex char(1) check(sex="男" or sex="女") comment "性别",
phone varchar(11) not null, unique comment "手机号",
city_id int reference city(id) comment "城市id" -- 外键(O)
foreign key(city_id) references city(id);-- 外键
) comment "测试约束";

create table city (
id int primary key comment "城市id",
name varchar(100) comment "城市名"
);

-- 2. 通过修改表来添加约束
alter table 表名 add primary key(字段名); -- 添加主键约束
alter table 表名 add unique(字段名) -- 添加唯一约束
-- 注意：是用modify来添加非空约束，还要带上字段的类型
alter table 表名 modify 字段 类型 not null;
alter table 表名 add check(sex in('男','女')); -- 添加检查约束
-- 注意：是用alter来添加非空约束
alter table 表名 alter column 字段 set default 默认值;
或 
ALTER TABLE 表名 CHANGE 字段名 字段名 数据类型 DEFAULT 默认值;

alter table 表名 add foreign key(city_id) references city(id); -- 添加外键约束。
```

## 9. 数据库范式 ==面试题==

> 范式有6层，一层比一层严格，层数越高数据安全性越高，但效率会越低。
>
> 结合安全性和效率，所以一般只考虑前3个范式。
>
> ![image-20240710162635227](D:\Pictures\MySQL\数据库范式.png)

* 第一范式（1NF）：要求设计数据库时__字段具有原子性__，也就是说不能将类似于对象，集合，数组这类不符合原子性的数据当成字段。

* 第二范式（2NF）：前提是必须先满足1NF，又要求其数据必须依赖于__主键__，==本质上就是为了让我们强制添加主键==，因为主键是唯一非空，这样可以防止数据的冗余。

* 第三范式（3NF）：前提是满足2NF，又要求__不能有其他表中的非主键列__，不然也会造成数据冗余（因为我们可以通过其他表的主键列来找到其他列，这样就没必要添加主键列以外的列来作为外键）强调了主外键的关联。

  > 但是第三范式在实际开发过程中是可以违反的，为了提高效率。不然每次都要通过外键列来查找其他列，效率太低。（因为很多时候都可能要用到两张表中的数据，如果遵守3NF，每次都要查询两张表，效率肯定没有查询一张表的效率高，所以违反3NF在表中添加一个冗余字段，这样只需要查询一张表，效率一定更高。这就是一种`空间换时间`的方式。

* BC范式（BCNF）：BC范式就是要求一张表中的其他非主键属性必须`直接`依赖于整个主键，不能存在任何间接依赖。

  > 什么是依赖？
  > 就像是可以通过学号字段直接找到班级字段，但没有办法通过班级字段找到学号字段，所以说班级字段依赖于学号字段。
  
  > BCNF 和 2NF 的区别在于，2NF是要求一定要有主键，BCNF是要求不存在间接依赖。
  >
  > BCNF相当于对3NF的扩充。

## 11. MySQL函数 ==重点==

> 类型于java中的方法，可以传参，`一定有返回值`

主要分三大类：

* 聚合函数：对多条数据，最终只会返回一个值，比如：最大值、最小值、平均值、总值。
* 单行函数：对于多条数据，最终每行数据都会返回一个结果，比如：拼接字符串。
* 自定义函数：

### 1. 聚合函数

* avg()
* count() : 返回数据的函数 
  count(distinct 字段)：`distinct`去重
* max()
* min()
* sum() ：返回指定字段的总和

前提：聚合函数一般可以写在select后面，同时还可以写在having后面。

### 2. 单行函数

#### a. 数字函数

> 主要用于处理数字（整数和浮点数），用来处理聚合函数的结果

```sql
abs(字段) ： 返回字段数据的绝对值
ceil(字段)：返回字段向上取整的值
floor(字段)：返回字段向下取整的值
rand(字段)：返回0-1的随机数
`round(字段，数值)：设置保留几位小数`
……
```

#### b. 字符串函数

> 类似于java中的String中的方法

```sql
char_length(字段)：返回的是该字段的字符长度。（一个中文算一个字符）
	比如：select char_length("中文123"); -- 5
length(字段)：返回该字段的字节长度。
	比如：select length("中文123"); --  9(UTF-8)
concat(s1, s2, s3, ……)：将所有字符串拼接在一起。
upper(字符串)：将字符串变为大写，对中文字符无效
lower(字符串)：将字符串变为小写
substring(字符串,下标,长度)：截取字符串，下标从1开始算，长度不写就截取到末尾
left(s,n)：返回字符串s的前n个字符，用来获取前缀
right(s,n)：返回字符串s的后n个字符，用来获取后缀

replace(s, 原内容, 新内容)：替换字符串内容
instr(字符串, "内容")：返回字符串指定内容下标
reverse(zfc)：反转字符串
……
```

#### c. 日期函数

```sql
now() : 当前时间，显示年月日时分秒
sysdate(): 当前时间，和now()一样
curdate(): 当前时间，只有年月日
	要时分秒用now(),不要时分秒用curdate()
year()/month()/day()/hour()\…… 获取日期数据的年月日时分秒
adddate(日期，天数) ：给日期添加几天
last_day(日期)：求当前日期当月的最后一天的日期数据
datediff(日期1，日期2)：求日期1-日期2的天数差
from_days(天数)：可以将天数转为日期类型。
				只支持365以上的天数转换，不满365就为0000-00-00
				每四年会减一天闰年
str_to_date(字符串，日期格式)：将字符串变成日期，但是mysql会自动将字符串转变为日期
date_format(日期，日期格式)：将日期按照指定格式转换为字符串
	注：mysql的日期格式比较特殊和java不一样（oracle和java一样）
	注意一下的大小写必须区分
	%W 表示星期名字 %D 表示月份英文前缀 %A返回星期的缩写
	%Y 表示四位年 %y 二位年 %m 月份 %d 表示日
	%H 表示24进制小时 %h 表示12进制小时 %i 分钟 %s表示秒
```

> %Y 年, 数字, 4 位
> %y 年, 数字, 2 位
>
> %M 英文月(June，October……)
> %m 数字月(01……12)
> %c  数字月，无前缀0(1……12)
> %b 缩写月(Jan……Dec)
>
> %H 24小时(00……23)
> %h 12小时(01……12)
> %k 24小时(0……23)
> %I 12小时(01……12)
> %l 12小时(1……12)
>
> %i 分钟, 数字(00……59)
>
> %S 秒(00……59)
> %s 秒(00……59)
>
> %r 时间,12 小时(hh:mm:ss [AP]M)
> %T 时间,24 小时(hh:mm:ss)
>
> %D 日期(1st, 2nd, 3rd, 等等。）
> %d 数字日期(00……31)
> %e 数字日期, 无前缀0(0……31)
>
> %W 星期名字(Sunday……Saturday)
> %a 缩写的星期名字(Sun……Sat)
>
> %j 一年中的天数(001……366)%p AM或PM
> %w 一个星期中的天数(0=Sunday ……6=Saturday ）
> %U 一年的第几个星期(0……52), 这里星期天是星期的第一天
> %u  一年的星期(0……52), 这里星期一是星期的第一天

#### d. 条件判断函数：

```mysql
if(表达式,值1,值2)：如果表达式为真返回值1，否则值2。
	比如：select if(1>0, "正确", "错误");
	
ifnull(字段,结果)：如果字段为null，就返回结果，如果不为null,就返回原来的字段。（MySQL独有）

case函数：最复杂，模拟Java中的if和switch功能，能用来实现列转行。
	-- 语法1：注意以end结束，类似于java多重if
	case
		when 条件1 then 结果1
		when 条件2 then 结果2
		……
		else 其他结果
	end
	-- 语法2：类似于java中的switch，不存在穿透。
	case 字段
		when 值1 then 结果1
		when 值2 then 结果2
		……
		else 其他结果
	end
	
--案例：
select name, if(sex = 1, "男","女") 姓别,
case status
	when 1 then "会员"
	when 2 then "超级会员"
	when 3 then "至尊会员"
	else "冻结"
end as 状态,
ifnull(card, "游客") as 卡号
from members;
```

#### e. 其他函数：

```sql
-- 系统信息函数，加密函数。
version()：返回mysql的版本。
	select version();
	
database()：返回正在使用的数据库名称。
	select database();
	
md5()：对字段进行加密，加密3次以上，网站就要花钱破解了。
	select md5("王亚林");
	
cast(字段 as 类型): 类型转换函数
	cast(name as signed int); -- 把查询出来的字段的数据转为有符号整型。
```

## 12. 分组查询

> 分组：group by：将查询的数据按照某个条件进行分组，这样就会将原来只有一个数据集变成很多组的数据集。（如果分组后，使用聚合函数后，每组都会返回一个结果。所以一般在select和having中写聚合函数）

```sql
分组语法：[]可有可无
select [聚合函数,] 分组字段 from 表
[where 分组前的条件]
[group by 分组字段]
[having 分组后的条件] -- 筛选的是每组的数据

-- 比如：统计公司中每个部门的平均工资和总和 要求显示部门平均工资大于2000
select deptno, avg(sal) 平均工资, sum(sal) 工资总和
from emp group by deptno
having 平均工资 > 2000;
```

> ==注：如果添加了分组，查询的字段只能是分组的字段或者是聚合函数，否则：在mysql默认显示第一行数据，在Oracle直接报错。==

## 13.连接查询 ==面试题==

如果当要查询的数据分散在不同的表中，这样如果只查询一张表就无法满足我的需求了，就需要实现多张表之间进行连接后查询，这种情况就叫做连接查询，连接查询主要分两种：

* 内连接：只会把满足匹配条件的数据查询出来，不匹配的数据查询不出来，匹配条件也叫关联条件。如果有一边为null就不会显示。
* 外连接：
  * 左外连接：会将左边的表当成主表，右边的表当成副表，主表的数据会全部展示，副表只会展示满足关联条件的数据，如果出现不满足的，显示null。
  * 右外连接：类似于左外连接，只不过是以右边的表作为主表。
  * 全外连接：==mysql不支持==，类似于左外连接，只不过左右两张表都是主表，没有副标，两张表的数据都会全部展示。

### 1. 内连接

```sql
-- 关键字：inner join on
-- 语法1：完整写法
select * from 表1 inner join 表2 on 关联条件
				  inner join 表3 on 关联条件
-- 关联条件：就是两张表可以共同描述同一个内容的字段 名称可以不同 但是含义一般是一样的。
-- 比如：员工表和部门表的关联 
-- 内连接：如果员工没有部门编号就查不出来，反之部门里面没有员工也查不出来。
select * from emp inner join dept
on emp.deptno=dept.deptno

-- 语法2：简化语法
select * from 表1,表2,表3
where 关联条件(表1.X = 表2.X and 表2.X = 表3.X)
```

### 2. 左外连接

```sql
-- 关键字：left join on
--         左表（主）  基准   右表
select * from 表1 left join 表2 on 关联条件
-- 主表的数据会全部展示，副表只会展示满足关联条件的数据
```

### 3. 右外连接

```sql
-- 关键字：right join on
--            左表    基准   右表(主)
select * from 表1 right join 表2 on 关联条件
-- 主表的数据会全部展示，副表只会展示满足关联条件的数据

-- 例子： 查询所有员工及其部门信息，包括那些还不属于任何部门的员工。
-- 外连接，可以为null的为主表
select e.* from emp e left join dept d
on d.deptno=e.deptno;

select e.* from dept d right join emp e
on d.deptno=e.deptno;
```

### 4. 全外连接

```sql
-- 关键字：full join on
--         左表（主）  基准   右表(主)
select * from 表1 full join 表2 on 关联条件
-- 主表的数据会全部展示，副表只会展示满足关联条件的数据
```

### 5. 自连接

> 自连接比较特殊，不是一种连接类型，而是一种连接的使用方式，本质上讲就是自己连接自己，把一张表当成两张表来处理。一般来说有一些非常抽象的题目通过自连接非常好解决。

```sql
-- 查询同一个学生，课程3-105 比 课程6-166成绩高的学生
select * 
from t_score s1, t_score s2
where s1.sno=s2.sno and s1.cno="3-105" and s2.cno="6-166" and s1.degree>s2.degree;
```

## 14. 子查询

![image-20240715141325540](D:\Pictures\MySQL\子查询.png)

### a. where 型子查询

把内层查询的查询结果当成外层查询的条件。

```sql
-- 比如：查询ID最大的一件商品
-- 法1： 先查询最大ID，再用这个查询结果来查询商品信息
select * 
from goods 
where id = (select max(id) from goods);
```

### b. from型子查询

把内层查询的查询结果当成一张`临时表（这个临时表最好加上别名）`，一般用于和外层查询做表关联使用。

```sql
-- 比如：查询每个科目最高分的学生学号 score student
-- 步骤1. 先查询每个科目最高分信息
select cno, max(degree) 最高分 
from score
group by cno
-- 步骤2. 成绩表 和 上面的临时表进行连接， 查询每个科目最高分的学生学号
select distinct s.sno
from score s, (上面的子查询) s2
where s.cno = s2.cno and s.degree = s2.最高分
```

### ==c. exists型子查询 (sql优化)==

##### in 和 exists的区别（什么时候使用in）

![image-20240715143523935](D:\Pictures\MySQL\exists型子查询.png)

> 等价于in关键字的基本使用，有in的地方都可以用in进行替换。==但是existis的效率更高。==

> 执行方式：如果子查询结果存在，如果内层查询数据和外层没关联就会全部查询，如果存在关联就只查询有关联的数据

```sql
-- 语法1： 判断子查询的结果是否存在
-- 执行方式：如果子查询结果存在，如果内层查询数据和外层没关联就会全部查询，如果存在关联就只查询有关联的数据
-- 如果子查询结果不存在 则外层查询什么都查不到。
select * from 表 where exists (子查询)
-- 语法2： 判断子查询的结果是否不存在
select * from 表 where not exists (子查询)
```

> -- exists型子查询
> -- 如果结果存在，哪怕只有一条，外层查询就查询所有
> -- ==如果子查询中的数据和外层查询没有关联，就会全部查询，存在关联就查询有关联的数据==
>
> select * from student s
> where EXISTS
> (select * from t_score sc where cno="6-166" and sc.sno=s.sno)

> 注： exists 子查询如果子查询数据量特别大，执行效率会高于in()，也是后期优化sql语句的一种方式。

## 15. 索引 ==（重点、难点、面试题）==

### ==1. 什么是索引？==

> 索引是数据库中的一种结构，它可以加快select语句的查询效率。它可以不断的缩小查询数据的范围。从而节省了查询的时间。
> 它类似于字典。只需要找到是那一页的数据，而不需要逐一的去查询。它的底层是B+树来实现的。

### 2. 索引的分类

> * ==普通索引==：index
> * ==唯一索引==：unique      （唯一约束会自动添加唯一索引，也可以手动添加唯一索引）
> * 主键索引：primary key （主键约束会自动添加主键索引，不能手动添加主键索引）
> * 全文索引：fulltext         （用于搜索很长的一篇文章）(全文索引和普通索引都存在，会优先索引全文索引)
> * 联合索引：                     （用多个字段来构成一个索引）
>   * ==联合普通索引==：index(id, name)
>   * 联合主键索引：primary key(sid, cid)
>   * 联合唯一索引：unique(name, card)

```sql
-- 假设一张表
会员编号 int        --- 适合主键索引
会员姓名 varchar    --- 适合普通索引  联合普通索引
身份证号 varchar    --- 适合唯一索引
会员电话 varchar    --- 适合唯一索引  联合普通索引
会员地址 varchar    --- 适合普通索引
会员备注信息 text    --- 适合全文索引

但是注意：索引不是越多越好。
```

### 3. 索引的创建和删除

```sql
-- 创建索引语法1：
create [unique | fulltext(全文索引) | 普通索引不用写该选项] index 索引名 on 表名(字段)

-- 创建索引语法2：
alter table 表名 add [unique | fulltext | 普通索引不用写] index 索引名(要加索引的字段名)

-- 删除索引：
drop index 索引名 on 表
```

> 可以给一个字段添加多个索引。

> 如何使用索引？
>
> 添加了索引的字段 作为查询条件时 就会通过索引来快速定位数据范围，提高查询速度。
> 数据库在查询数据时会默认使用，我们无法显示调用索引。

### ==4. 如何查看是否走索引？==

> 通过mysql的一个命令 `explain` 查看一条sql语句的执行计划，也可以查看sql语句整体性能，也可以查看到是否执行了索引。看结果表中的type\possible_keys\key三个字段来判断。
>
> 语法：explain + 查询语句。

### 5. 怎么查询一条sql语句的执行性能？

#### a. explain的查询结果

> ![image-20240715161755753](D:\Pictures\MySQL\explain.png)
>
> * select_type: 表示是否有 多表关联 或 子查询 或 union。
> * table:  查看这条sql语句涉及到的几张表。
> * ==type==：可以查看sql语句的整体性能 也可以查看是否走了索引。
> * possible_keys 和 key： 这两者类似的，如果不走索引值为null, 走了索引一般是有值的。
> * rows：表示执行sql语句过程中估算的行数，不是精确的值。

#### b. sql语句的性能级别

> sql语句的性能从高到低（type字段）：==优化sql语句最低级别至少要达到range以上==
>
> system > const > eq_ref > ref > fulltext > range > index > all
>
> * system ： 最高级别，一般是无法达到的，只有在一行数据的表或者空表，但InnoDB引擎都是all。
> * `const`    ：表示使用主键索引或唯一索引查找单条数据时。
> * `eq_ref`   ：用于连接查询，一个表只返回一条记录，并且这个记录是另一个表的主键或者唯一键，而且必须是not null。（查询的字段是别的表的主键或非空唯一键）
> * `ref` ：一般是普通索引作为条件查找单条数据时。
> * `fulltext` ： 全文索引查找单条数据时，如果全文索引和普通索引都存在，会优先索引全文索引。
> * `range` ：用索引走了范围查询（between >  < in like)。
> * index ：用索引全表扫描，就是查询时不带条件且查询的是带索引的字段，会从头到尾把表扫描一遍。
> * all  ：全表扫描，不使用索引。

```sql
-- 查询结果为空时级别为null

-- 级别1：
-- system: 最高级别 表只有一行或为空时
-- 注意InnoDB引擎 返回all
-- 可以更改引擎 或 用虚拟表（select 1）来看
explain select * from (select 1) s;

-- 级别2：
-- const:泛指使用了主键或唯一键作为查询条件时
explain select * from testIndex2 where id = 5;
explain select * from testIndex2 where card = '身份证2';

-- 级别3：
-- ref：一般非唯一索引（普通索引）作为条件查找单条数据时
explain select * from testIndex2 where name = "姓名";

-- 级别4：
-- fulltext : 全文索引 （要使用全文索引，必须嵌套一个match()否则不会使用全文索引，级别就为普通索引)
explain select * from testIndex2 where match(mess) against ("介绍1");

-- 级别5:
-- range ：用索引走了范围查询（between >  < in like)
explain select * from testIndex2
where id between 1 and 5;

-- 级别6：
-- index ：用索引全表扫描
explain select id from a;

-- 级别7：
-- all 不使用索引
```

####  ==c.索引是不是越多越好？== 

> 不是，添加索引确实能提高查询速度，但是如果每列都添加了索引，会降低增删的效率，因为在增加、删除、更新数据时要`维护索引`。

### ==6. 联合索引的最左匹配原则?==

> 最左匹配原则：主要是给联合索引使用的，在联合索引中，如果==查询条件涉及到索引的多个字段==，只要联合索引最左边的字段匹配了，就会走联合索引。但是最左边的字段没匹配上，即使后面的字段都匹配了，也不会走联合索引。

```sql
-- 一个联合索引(A,B)
select * from 表 where A="值1" and B="值2"
-- 只要最左边的值匹配上了就会走联合索引，如果A不满足，B满足它就不会走联合索引。

-- 一个联合索引包含(A,B,C)
-- 匹配(A) 匹配(A,B,C) 匹配(A,C) 都会走联合索引。
```

### 7. 索引什么时候失效？

> 是什么？ -- 指在有索引的情况下索引级别为All。
>
> ==如果表中的所有字段都设置了索引，不会出现索引失效的情况==
>
> * 使用or ：因为or两边的字段不一定都使用了索引，只要一边没有索引，就会导致失效。
> * 使用模糊查询：使用前%不走索引，后%走索引。原因在于：前%包含0-n个字符不知道从谁开始匹配。
> * ==如果条件是字符串内，如果不加""，mysql会`自动类型转换`== 也不会走索引 （如100 -> "100")
> * ==使用 `is null` 或者 is not null 也不会走索引。==因为null不是一个值，not null 则是因为要匹配所有值
> * ==索引的列参与了运算==，也不走索引。比如：where id+10=30; 不走索引，因为索引里面没这个值
> * ==索引的列调用了函数==，也不走索引。比如：where concat(name,"100")=XXX; 
> * 使用了不等于<> 作为 条件也不会走索引。

### 8. 索引底层的数据结构是什么？

> 为什么mysql会采用B+树数据结构来作为索引？

* 数组：增删太慢，数据库无论是对增删改查都要考虑性能，所以不适合作为索引。

* 链表：查询太慢，所以不适合作为索引。

* 哈希表：只能做等值判断，虽然兼容了数组和链表的特点，增删 和 查询都非常快，不考虑hash冲突的情况下，查询的时间复杂度是O(1)，但是hash表中的元素是无序的，==无法实现范围查询，所以它不适合作为索引。==

* 二叉树（二叉排序树 BST）：当插入的数据有序，有可能退化为链表，查询就会非常慢。O(n)

* 平衡二叉树（AVL)：因为没有控制高度，所以不适合做索引。高度越高效率越低。

  > 平衡二叉树是否适合做索引：不适合，因为这是一个树的通病，因为树的高的越高，效率越低。但是树无法控制高度。所以说如果数据量小，可以用，但是数据库的数据量一般都比较大

  > 任何节点的两个子树的高度差不会超过1，而且左右两个子树又是一个平衡二叉树。

* 红黑树（RB-Tree)： 和平衡二叉树一样，因为==没有控制高度==，所以不适合做索引。

  > 红黑树是一种能实现自我平衡的有序二叉树，但是不是通过高度来控制平衡的，而是通过节点的红色和黑色来让插入时自动达到平衡的。
  >
  > 
  >
  > 2.红黑树特点：
  >
  > * 每个节点只能是红色或者黑色。
  > * 根节点必须为黑色的。
  > * 每个存储null的叶子节点也是黑色的。
  > * 如果有一个节点是红色的，那么它的子节点必须是黑色的，即不允许有连续的红色。
  >
  > 最后：可以保证从根节点到任何叶子节点，黑色的数量一定是一样的，就达到了颜色平衡。
  >
  > ==从根到每个叶子的每条路上的黑色节点都是一样的。==
  >
  > 3.红黑树的插入规则：
  >
  > 插入规则和普通二叉树一样，大的放在右子树，小的放在左子树。
  >
  > 两个点：1. 颜色的改变  2.自旋
  >
  > 插入元素时：这个节点默认为红色，如果双亲节点是黑色的就没有违反红黑树的规则（黑色数量一致 没有连续的红色）则不用调整；如果双亲结点是红色的 则违反了规则 这个时期触发自旋。

* B-树：不适合，原因在于每个节点都存储了很多数据，单个节点存储的容量很小，虽然高度降低了，但是每个节点在数据量特别庞大时可能出现空间不足，所以==不适合做大量数据存储==。

  > B-树底层就是一个平衡二叉树，区别在于每个节点存储了很多的内容(key[主键]和value[除了主键的数据]和指向下个节点的指针)这样就可以降低树的高度，而且也可以减少IO读取磁盘的次数。
  >
  > ![image-20240716162113849](D:\Pictures\MySQL\B-树.png)

* B+ 树：

  > B+ 树：B+树也是一种特殊的平衡二叉树，它其实就是对B-树的升级版，同样可以降低树的高度，减少IO读取磁盘次数，相比B-树，它的每个节点不会存储这么多的内容，根节点和左右子树 一般只存储指针和数据主键，最后所有数据全部存储到叶子节点，这样就可以给叶子节点分配更大的空间，适合做大量存储，而且它的每个叶子节点是连接在一起的，这样又形成了有序的环形链表，非常适合做范围查找，所以MySQL采用B+树做索引。
  >
  > ![image-20240716162439864](D:\Pictures\MySQL\B+树.png)
  >
  > 叶子节点还是一个环形链表。

  > B+ 树相比于B-树的优势：
  >
  > B+ 树和B-树相比于AVL\RBT的优势在于控制了树的高度，减少了io读取次数。
  >
  > B- 树的缺点：相比于B+树，每个节点都会存储主键、数据、指针。但每个节点的容量有限，所以很可能出现空间不足的问题。

## 16. 视图

### 1. 什么是视图

> 视图(view)就是对查询语句的封装，每次执行视图时，只相当于把里面封装的==查询语句==执行一遍（所以不会占用空间存储表中数据）。

> 可以在视图里创建一张表吗？
>
> 不可以，==视图里只能放查询语句==，不能放插入、删除、更新语句，去修改表的内容。

### 2.视图的特点

> 优点：
>
> * 简单：使用视图只要会调用即可，不管视图里面封装了多么复杂的查询语句，所以对使用者来说非常简单。
> * 安全：视图对查询语句进行了封装，使用视图的用户只能访问被允许查询的数据字段，而具体的表结构是无法查看的。
>
> 特点：
>
> * ==视图不能提高查询效率==：原因在于每次使用视图只是把封装的查询语句执行一遍，没有优化过
>   ==通过视图查询出来的数据还在原来的表中。==

### 3. 视图的使用

查询的时候把视图当成一张表来使用就可以了。

```sql
-- 1.创建视图（create)
create view 视图名 as 查询语句(只能封装select查询语句,其他的插入、更新语句都不行)

-- 2.如何使用视图：把视图当一张表来用就可以了
select * from 视图名 where 条件;

-- 3.如何删除视图
drop view 视图名;
```

#### 视图的使用案例

```sql
-- 视图的基本使用
-- 查询每个学生姓名，课程名，成绩，任课老师
select s.sname, c.cname, sc.degree, t.tname
from student s, t_score sc, t_course c, t_teacher t
where s.sno = sc.sno and sc.cno = c.cno and c.tno = t.tno;

-- 1. 把上面的查询语句封装成视图 (as后面不需要括号因为不是子查询）
create VIEW student_exam_info 
as 
select s.sname, c.cname, sc.degree, t.tname
from student s, t_score sc, t_course c, t_teacher t
where s.sno = sc.sno and sc.cno = c.cno and c.tno = t.tno;

-- 2. 使用视图(当成表使用)
select * from student_exam_info where sname = "曾华";

-- 3. 对视图进行查询
-- 统计每个老师 的 学生人数 和 平局分
select tname, count(1) num, round(avg(degree),1) avg 
from student_exam_info 
group by tname 
having avg > 50

-- 4. 把视图的查询结果封装成二次视图
create view teacher_course_info
AS
select tname, count(1) num, avg(degree) avg 
from student_exam_info 
group by tname 
having avg > 50

select * from teacher_course_info;

-- 对原来的查询语句修改不会影响视图，因为视图已经封装好了之前的语句。
-- 5.修改视图
alter view teacher_course_info
AS
select tname, count(1) num, round(avg(degree),1) avg 
from student_exam_info 
group by tname 
having avg > 50

-- 6.删除视图 视图2（视图1）
-- 能不能先删视图1？ -能，但是视图2就用不了
-- 删除内层视图和外层视图都可以
-- 只不过删除内存视图后 外层视图的使用会受到影响。
drop view student_exam_info;
select * from teacher_course_info;
drop view teacher_course_info;
```

## 17. 事务

### 1. 什么是事务？

> 事务就是绑定在一起的逻辑工作单元，这个工作单元可能包含很多sql语句，保证这么多语句要同时执行成功，要么同时执行失败。

### 2. 事务的四大特性（ACID）

> * 原子性：事务是一个不可分割的工作单位，事务中的所有操作要么全部成功，要么全部失败。
>
>   ```txt
>   原子性指的是事务是一个不可分割的工作单位，事务中的所有操作要么全部成功，要么全部失败。如果事务中的某个操作失败了，系统必须撤销该事务中的所有操作，使得数据库回到事务开始前的状态。
>   ```
>
> * ==一致性==：数据在运行前后的结果一定保持一致。
>
>   ```txt
>   一致性指的是事务必须使数据库从一个一致性状态变换到另一个一致性状态。也就是说，事务的结束不应该破坏数据的完整性。例如，银行转账操作，无论事务成功与否，账户的总金额都应该保持不变。
>   ```
>
> * 隔离性：一个事务和其他事务是不能相互干扰的。
>
>   ```txt
>   如果userA的数据正在被一个事务进行操作，其他事务是无法再对userA的数据进行操作，只有等待事务提交时，其他事务才可以操作
>   ```
>
> * ==持久性==：一旦事务提交了，对数据的修改是永久的。
>
>   ```txt
>   如果没有提交事务，就可以回滚事务(可以将之前的数据进行撤销)，但是事务提交后就无法回滚
>   ```

### ==3. 事务并发问题==

> * `脏读`：脏读发生在一个事务读取了另一个事务未提交的更改。如事务A读取了事务B更新的数据，然后事务B突然回滚了事务，那么事务A读取的数据就是脏数据。==(未提交事务，回滚事务导致)==
> * `不可重复读`：事务A多次读取同一个数据，事务B在事务A读取过程中突然`对数据更新`提交了事务，导致事务A多次读取相同的数据不一致。==（提交事务更新`单个`数据导致）==
> * `幻读`：事务A多次读取同一个数据，事务B在事务A读取过程中突然`对数据新增或删除`并提交了事务，导致事务A多次读取相同数据行数不一致。==（提交事务增加或删除`某行`数据导致）==
>
> 幻读与不可重复读的区别在于：
>         不可重复读关注的是行中数据本身的变化（即数据被更新了）
>         而幻读关注的是数据行数量的变化（即数据被插入了或删除了）。

### ==4. 事务的隔离级别==

> 既然存在三种并发问题，数据库同样也提供了解决这种问题的机制，这种机制可以通过控制事务隔离级别来实现。
>
> 数据库本身是支持多个事务之间同时对数据进行读写的，而隔离级别可以防止多个事务之间并发执行导致数据不一致问题。

| 隔离级别 |   脏读   | 不可重复读 |   幻读   |
| :------: | :------: | :--------: | :------: |
| 读未提交 | 无法解决 |  无法解决  | 无法解决 |
| 读已提交 | 可以解决 |  无法解决  | 无法解决 |
| 可重复读 | 可以解决 |  可以解决  | 无法解决 |
|  串行化  | 可以解决 |  可以解决  | 可以解决 |

> 串行化就相当于加锁，每次只允许一个事务对数据进行操作。
>
> 可重复读：即在该事务开始时刻保存一个数据快照，在此事务结束前，其他事务对这些数据的修改对该事务来说是不可见的。

#### ==mysql和oracle的默认事务隔离级别==

> ==mysql的默认事务隔离级别：可重复读==
>oracle的默认事务隔离级别：读已提交
> 因为隔离级别越高，数据安全性越高，但是性能也会越低，所以数据库默认采用的不是最高也不是最低的。

### 5. mysql的事务处理

> ==oracle数据库是要手动提交事务的，但mysql是自动提交事务的。==mysql每次做完增删改之后都会自动执行commit(提交事务的)，如果mysql想要手动做事务，需要设置一个命令`set autocommit=0`来关闭自动提交。
>
> ```sql
> set autocommit=0 -- 关闭事务自动提交
> set autocommit=1 -- 开启事务自动提交（mysql默认）
> 
> -- 手动做事务的方式：
> begin -- 开启一个新事物
> ... -- 这里可以插入很多条sql语句（在 内存 中执行的）
> commit;  -- 提交事务  (把上面的语句真正执行，对 磁盘 中的数据进行修改)
> rollback; -- 事务回滚 (把上面的...语句执行全部撤销，事务提交后没有办法回滚)
> 
> -- end -- 在MySQL中，不是使用END来结束一个事务的。实际上，END关键字在MySQL事务控制中并不使用。
> ```
>
> 案例：
>
> ```sql
> -- 测试事务
> -- 设置手动提交事务
> set autocommit=0;
> -- 设置自动提交事务
> set autocommit=1;
> 
> -- 开启事务
> begin;
> -- 测试没有提交事务时，数据是在内存中保存的，没有提交到磁盘中。（直接查看表中数据发现没有更新）
> insert into phone values (11111111111);
> update phone set number = 111 where number=11111111111;
> select * from phone;
> -- 测试撤销事务
> rollback;
> -- 测试提交事务（直接查看表中数据发现更新了）
> commit;
> ```

> 开启事务后，如果没有使用commit提交事务，磁盘中的数据是没有更新的，直接打开表来查看数据时是没有更新数据的。但是能用select查看到内存中的修改。

## 18. ==行转列 & 列转行==

### 1. 行转列

> 是什么？
> `把多行数据按某个字段聚合起来`（如姓名）使其成为一行。
> 把一行中的一个字段和一个主要字段关联起来(如名字），使用聚合函数按这个主要关联字段来聚合，通过if()函数来筛选出其他字段，通过多个if()函数来筛选多个字段来整合到同一行。

> ==借助于聚合函数 + if()/case==
> if()/case的作用是把不符合条件的成绩变为0，然后通过聚合函数max()或sum()筛选出来。
>
> ```sql
> create table rowtocol (
> id int auto_increment primary key,
> name varchar(30),
> course varchar(100),
> score decimal(4,1) comment "分数"
> ) comment "测试行转列";
> 
> insert into rowtocol VALUES
> (null, "郭皓", "java", 85),
> (null, "郭皓", "mysql", 80),
> (null, "郭皓", "project", 70),
> (null, "胡涵", "java", 90),
> (null, "胡涵", "mysql", 70),
> (null, "胡涵", "project", 0),
> (null, "万成", "java", 85),
> (null, "万成", "project", 75);
> 
> -- 使用 聚合函数 + if()：
> -- if()的作用是把不符合条件的成绩变为0,然后通过聚合函数max()或sum()筛选出来
> select name, 
> max(if(course="java", score,0)) java成绩, 
> max(if(course="mysql", score,0)) `mysql成绩`,   
> max(if(course="project", score,0)) `project成绩` 
> from rowtocol
> group by name;
> 
> -- 使用case when then else end
> select name, 
> sum(case course when "java" then score else 0 end) java成绩, 
> sum(case course when "mysql" then score else 0 end) `mysql成绩`,   
> sum(case course when "project" then score else 0 end) `project成绩` 
> from rowtocol
> group by name;
> -- 使用sum存在bug:当补考的时候一门科目就存在两个成绩。
> ```

### 2. 列转行

>`把一行的数据进行拆解`，把一行中的多个字段分别和一个主要字段关联起来，就是一次只查询这两个字段，然后进行多次查询把每个字段和主要字段的关联都查询出来，最后用union或union all把上面的多个查询连接起来。

> ==借助于union或union all 合并查询结果集==
>
> ```sql
> create table coltorow (
> id int primary key auto_increment,
>     name varchar(100),
>     java_score decimal(4,1),
>     mysql_score decimal(4,1),
>     project_score decimal(4,1)
> );
> insert into coltorow VALUES
> (null, "郭皓", 90, 80, 70),
> (null, "胡涵", 0, 75, 70),
> (null, "万成", 80, null, 70);
> select * from coltorow;
> 
> select name, "java" course, java_score score
> from coltorow
> UNION
> select name, "mysql" course, mysql_score score
> from coltorow
> UNION
> select name, "project" course, project_score score
> from coltorow
> order by name; -- 根据姓名排序
> ```

## 19.==SQL语句的优化==

* 添加索引 可以加快查询效率
* 尽量避免索引失效，使用or、is null/is not null、<>/!=、前%模糊查询、索引的列参与了运算
* 禁止使用 * 来做查询，需要查询具体字段
* 使用exists来代替in，如果子查询结果集数据量很大时，用exists来代替in
* 用表连接来代替子查询
* 如果查询数量很少 可以合理使用limit 来限定行数
* 分库 和 分表
  * 分库：把一个庞大的数据库拆分成很多子数据库，查询时只需要针对一个子库查询即可。
  * 分表：将一个大表拆分成很多子表，查询时根据需求查询某个子表。
  * 分表的方式：
    * 垂直拆分：按列拆分，如把前n个字段，和后n个字段分别存储到不同的子表中去。
    * 水平拆分：按行拆分，如把前10w行数据放到一个子表中，后10w行数据放到另一个子表中。



## 20.==查询语句中各关键字的执行顺序==

> 查询语句中各关键字的执行顺序：
>
> ​						 `分组前筛选`                  `分组后筛选`           `对查询结果排序`
> ​           from  >  where  >  group by  >  having  >  select  >  order by  >  limit
> `获取表中数据`                                               `成功查询到数据`

##  21. ==存储引擎==

> ![image-20240717164046805](D:\Pictures\MySQL\存储引擎.png)
>
> ```sql
> -- 查看mysql的所有存储引擎
> show engines;
> ```

### 1. MyISAM引擎 和 InnoDB引擎的区别

> * MyISAM：
>   * mysql==5.5==之前(包括5.5)的默认存储引擎
>   * ==不支持事务==
>   * 适用于读操作远远大于写操作的时候，比如数据仓库
>   * ==不支持外键，要确保完整性要自行控制。==
> * InnoDB：
>   * mysql5.5之后的默认存储引擎
>   * 支持事务，满足事务的四大特性：ACID
>   * 适用于需要频繁进行数据更新、插入操作，比如：在线交易
>   * 支持外键约束，可以保证数据的完整性。

> 为什么说MyISAM适用于读操作远远大于写操作的时候?
>
> 这是由于它的锁机制所决定的：
>
> ### 锁机制
>
> - **MyISAM**：使用表级锁，这意味着在对表进行写入操作时，会锁定整个表，从而阻塞其他用户对该表的读写操作。虽然MyISAM在读取操作时可以并发进行，但在写入密集的应用中，性能会受到较大影响。
> - **InnoDB**：支持行级锁和外键约束。行级锁可以大幅度提高多用户并发操作的性能，减少锁定冲突。同时，InnoDB还支持多版本并发控制（MVCC），允许读操作不阻塞写操作，提高了并发性能。

## 22. MySQL中的面试题

> 1. 关系型和非关系型数据库区别？
> 2. SQL语句分类？
> 3. MySQL常用的数据类型？
>    * char 和 varchar 的区别
>    * ==datetime和timestamp区别==
> 4. 内连接和外连接的区别
> 5. 索引
>    * 什么是索引？
>    * 怎么查看索引？
>    * ==索引的分类？==
>    * 怎么查看一条sql语句的性能（explain）和 ==级别==
>    * ==索引什么时候失效？==
>    * 最左匹配原则
>    * 索引的数据结构？
> 6. 视图能不能提高效率？为什么？
> 7. 事务
>    * 什么是事务？
>    * ACID
>    * 事务并发问题？
>    * 事务隔离级别？（MySQL的默认级别）
> 8. 行转列 和 列转行
> 9. sql语句优化
> 10. sql语句关键字的执行顺序
> 11. MyISAM 和 InnoDB存储引擎



# 二、MySQL疑难杂症

### 1.char()的细节

> MySQL的char类型后面()中的数字是代表字符大小还是字节大小？
>
> MySQL的`CHAR`类型后面`()`中的数字代表的是字符的最大长度，而不是字节。`CHAR`是一个固定长度的字符串类型，当你定义一个`CHAR`类型的列时，你需要指定一个长度，这个长度指的是该列可以存储的最大字符数。
>
> 例如，如果你定义了一个`CHAR(10)`类型的列，这意味着这个列可以存储最多10个字符。如果存储的字符串长度小于10，MySQL将在其后填充空格以达到固定长度。如果尝试存储一个长度超过10的字符串，MySQL将返回一个错误。
>
> 需要注意的是，字符所占的字节数取决于字符集。例如，在`latin1`字符集中，一个字符通常占用1个字节，而在`utf8`字符集中，一个字符可能占用1到3个字节，在`utf8mb4`字符集中，一个字符可能占用1到4个字节。因此，当你定义一个`CHAR`类型的列时，你需要考虑到字符集对存储需求的影响。
>
> MySQL的`VARCHAR`类型后面`()`中的数字代表的是字符的最大长度，而不是字节。`VARCHAR`是一个可变长度的字符串类型，用于存储可变长度的字符串。当你定义一个`VARCHAR`类型的列时，你需要指定一个长度，这个长度指的是该列可以存储的最大字符数。

### 2.drop、truncat、delete的区别

> drop ：属于DDL语言、事务是不可以回滚的
> 语法： drop table 表 -- 删除整张表
>
> truncate：属于DDL语言、事务是不可以回滚的、清空表（无法写条件，只能清空整张表）、==同时释放磁盘中的空间、不会删除表的属性（约束、索引……）==
> 语法：truncate table 表 -- 清空表（无法写条件，只能清空整张表）
>
> delete ：属于DML语言、可以进行事务回滚、添加条件来删除表中数据、==不会释放磁盘中的空间(事务提交后才会删除)、不会删除表的属性==
> 语法：delete from 表 where 条件  -- 添加条件来删除表中数据。
>
> 性能速度对比：drop > truncate > delete
> 因为drop是直接删除表、truncate是直接清空表中的数据、delete是先查条件后删除。
>
> truncate还会重置auto_increment的计数。
>
> ==truncate的机制是删除整张表后重新创建。但删除之前要判断是否被外键引用。==(官网)

### 3.Mysql中数据类型的转换

> 当数字和字符串比较时会将字符串转化为数字
>
> ```sql
> select '10'>'9' union all  -- 0 比的是ASCII码1和9比 
> select 10>'9' union all    -- 1 '9'转换为了数字9和10比较
> select '10'>9 union all    -- 1
> select 10>9;               -- 1
> ```
>
> ![image-20240802102140689](D:\Pictures\MySQL\MySQL中的数据类型转换.png)

### 4. sql语句中 and 和 or 的优先级

> sql语句中and的优先级大于or，所以下面要用（）来提升or的优先级：
>
> ![image-20240805101922216](D:\Pictures\MySQL\and和or的优先级.png)

### 5. 数据库优化

> 数据库性能优化是数据库管理员必须掌握的重要技能之一，它涉及多个方面，包括查询优化、索引使用、数据库设计、缓存技术、工具和硬件升级等。以下是一些具体的优化方法和策略：
>
> ### 一、查询优化
>
> * **优化查询语句**：编写高效的SQL查询语句是提高数据库性能的关键。避免使用复杂的子查询和多重连接，优化查询语句的结构和条件，使用合适的索引等。例如，__避免使用SELECT *查询__所有列，只选择需要的列可以减少返回数据的大小，从而提高查询速度。
> * **使用索引**：索引是提高数据库查询效率的关键。通过在经常查询的列上创建索引，可以加速数据的检索过程。但是要注意不要过度使用索引，因为过多的索引可能会影响插入和更新操作的性能。
> * **使用连接池**：数据库连接的创建和销毁开销较大。使用连接池可以复用已经建立的连接，避免频繁的连接和断开，从而提升性能。
> * **使用缓存**：通过缓存常用的查询结果，可以避免重复执行相同的查询。缓存技术可以显著提高数据库的性能，特别是对于高流量的网站和应用程序。可以使用数据库查询缓存、应用级缓存（如Memcached、Redis）等技术。
> * **分析查询执行计划**：如果还不够，可以使用__EXPLAIN关键字__来查看查询的执行计划，然后进行分析。
>
> ### 二、数据库设计优化
>
> * **按照数据库范式设计表结构**：可以减少数据的冗余。
> * **选择合适的数据类型**：选择合适的数据类型可以__减少存储空间__，提高查询效率。例如，避免使用不必要的大数据类型，对于大文本数据，应尽量使用BLOB和CLOB数据格式。
> * **分库分表**：将一个大表分成多个小表可以提高查询性能。
>
> ### 三、消息队列和负载均衡
>
> * **消息队列**：
> * **负载均衡**：在多个数据库服务器之间分配查询请求，避免单个数据库负载过高导致性能下降。可以使用负载均衡器来动态调整请求的分配。
>
> ### 四、硬件升级和配置优化
>
> * **增加内存**：增加内存可以提高数据库的缓存效率，减少磁盘I/O操作，从而提高查询速度。
> * **使用SSD**(固态硬盘)：将磁盘换成固态硬盘，使用SSD可以显著提高数据读写速度，缩短响应时间。
> * **使用RAID技术**：RAID技术可以提高数据的容错能力和读写性能。
>
> ### 五、定期维护和监控
>
> * **定期备份和恢复**：定期备份数据库，并测试恢复过程，以保证数据安全和可靠性。==(高可用)==
> * **重建和优化索引**：定期重建和优化索引，特别是在数据频繁更新的情况下，可以防止索引碎片化，保持查询性能。
>
> 综上所述，数据库性能优化是一个复杂而系统性的工作，需要综合运用多种技术手段和方法。在实际应用中，需要根据具体的业务场景和需求进行针对性的优化。同时，还需要不断地学习和实践，以适应不断变化的业务需求和技术环境。

### 6. 聚簇索引和非聚簇索引

> 1. 聚簇索引：
>
>    * 聚簇索引就是B+树中叶子节点存储整行数据，索引和数据存放在1一起。
>    * 一个表只能有一个聚簇索引。
>
>    * 在InnoDB存储引擎中，聚簇索引通常是根据主键构建的。如果没有定义主键，InnoDB会选择第一个唯一且非空的索引作为聚簇索引；如果这样的索引也不存在，InnoDB会隐式地定义一个主键（如row_id）来作为聚簇索引。
>
> 2. 非聚簇索引：
>
>    * 非聚簇索引就是B+树中叶子节点存储索引列的值和指向数据行的指针(就是聚簇索引的key)，将索引与数据分开存储的索引。
>    * 一个表可以有多个非聚簇索引。
>    * 慢于聚簇索引，因为需要回表操作。
>    * 当通过非聚簇索引查询数据时，首先会在索引中找到对应的叶子节点，然后通过叶子节点中的指针访问实际的数据行。这个过程称为“回表”。

### 7. 回表查询

> 如何优化回表查询：使用联合索引( 覆盖索引)。

> 回表查询是数据库查询过程中的一种现象，主要发生在具有索引的数据库表中。为了理解回表查询，我们首先需要了解索引和数据库表的基本结构。
>
> 在数据库中，索引是为了加速数据检索而创建的一种数据结构。索引通常包含了表中的一列或多列的值，以及这些值在表中的物理位置（如行号或页号）。当执行查询时，数据库首先使用索引来快速定位满足查询条件的记录位置，然后再根据这些位置去实际的数据表中读取完整的记录。
>
> 回表查询发生在以下情况：
>
> 1. **非聚簇索引**：在数据库如MySQL的InnoDB存储引擎中，如果表有一个非聚簇索引（Secondary Index），那么该索引只包含了索引列的值和对应的主键值（如果是复合索引，则包含索引列的组合和主键值）。__当查询的列不在索引中__，或者查询需要获取完整记录而非仅仅是索引列的值时，数据库首先使用索引找到满足条件的记录的主键值，然后再根据主键值回到数据表（聚簇索引）中查找完整的记录。这个过程就是回表查询。
>
> 2. **覆盖索引缺失**：如果索引能够覆盖查询（即查询所需的所有列都包含在索引中），那么就不需要进行回表查询。然而，如果索引不能覆盖查询，数据库就需要执行回表查询来获取额外的列数据。
>
> 3. **查询优化**：在某些情况下，即使索引能够部分覆盖查询，数据库也可能选择执行回表查询以获取更完整的数据，这取决于查询优化器的决策和具体的查询场景。
>
> 回表查询会增加查询的I/O成本，因为需要多次访问磁盘或内存来获取数据。为了减少回表查询的开销，可以采取以下措施：
>
> - **使用覆盖索引**：尽量设计索引以覆盖查询，从而避免回表查询。
> - **优化查询语句**：通过优化SQL查询语句，减少需要回表查询的情况。
> - **考虑聚簇索引**：在可能的情况下，使用聚簇索引（Clustered Index），因为聚簇索引本身就是数据表的一部分，不需要额外的回表查询。
> - **硬件升级**：提高I/O性能，如使用更快的磁盘或SSD，以减少回表查询的延迟。
>
> 总之，回表查询是数据库查询过程中的一个常见现象，通过合理的索引设计和查询优化，可以有效地减少回表查询的开销，提高数据库的性能。

### 8. MySQL的备份和还原和定期备份

> * 手动备份：`mysqldump`
>
>   ```sql
>   mysqldump -u账号 -p密码 --default-character-set=utf8 -B 要备份的数据库名> /usr/local/sql/test.$(date +%F).sql
>   -- 加上default-character-set选项就能识别中文了 注意是utf8 不是-8
>   -- B后面添加要备份的数据库，如果有很多数据库需要备份，则可以写多个 
>   -- 如果所有数据库都要备份-B后面加上选项 --all -databases
>   
>   --按日期生成文件名：
>   mysql> /usr/local/sql/test.$(date +%F).sql
>   --注意date后面有一个空格，不加空格不识别
>   ```
>
> * ==还原数据库==：前提是需要先登录mysql，在mysql中进行还原。
>
>   ```
>   source /usr/local/sql/xxx.sql
>   ```
>
> * ==定期备份(自动备份)==：cenos7系统 是通过cron来实现定期备份的任务，`cron` 是 Linux 和 Unix 系统中用于安排周期性执行任务的工具。主要负责定时任务的调度，可以根据用户需要来定义数据间隔，它便会自动执行任务。
>
>   ```sql
>   -- 1.先配置 cron job 配置文件
>   vi /etc/crontab
>   分钟 时 天 月 星期几  用户    执行什么命令
>    *  *  *  *  *   user-name command to be executed
>   --比如:11:58 执行mysq1备份任
>    58 11 *  *  *     root 备份任务
>   --比如:每周一到周五 凌晨零点 开始执行备份任务
>    0  0  *  * 1-5    root 备份命令
>   --比如:每分钟执行一次数据库备份任务
>   */1  * *  *  *    root mysqldump -uroot -proot -B sc240601>/usr/local/sql/cron.$(date +\%Y-\%m-\%d-\%H:\%M:\%S).sql
>   
>   -- 2.重启cron服务
>   systemctl restart crond
>   ```

### 9. 分库分表

> * 水平分库：
>   * 以字段为依据，按照一定的策略（取模、数据来源、数据范围如时间）将数据拆分到多个数据库中去。
>   * 当`并发量太高`的时候据可以考虑进行水平分库，多一个库，就可以将部署在不同服务器上。从而减少单台服务器的压力，从而提高并发量。
> * 水平分表
>   * 也是以字段为依据，按照一定的策略（取模、数据来源、数据范围如时间）将数据拆分到多个数据库中去。
>   * 并发量不高，但是`单个表中的数据量太多`，会影响查询效率。
> * 垂直分库
>   * 按照业务的不同，将不同表放到不同的数据库中去。
>   * 系统并发量太高，且可以按业务进一步拆分表。
> * 垂直分表
>   * 垂直分表就是按字段来将表中的字段拆分到不同表中去，可以按业务，也可以按数据热度。
>   * 并发量不高，表中数据也不多，但是字段多，并且热点数据和非热点数据在一起。这样可以减少缓存压力。

> **分库分表工具**：Sharding-jdbc
>
> ![image-20241025141618103](D:\AppData\Typora\typora-user-images\image-20241025141618103.png)

> **分库分表存在的问题：**
>
> 1. 主要是水平分库分表存在的问题：非分表字段的查询问题。
>    解决方法：
>    * 索引表法：再建立一张索引表，记录分表字段和非分表字段的关联
>    * 缓存映射法：在redis中保存字段间的映射关系
>    * 基因法：保存非索引数据时，在数据的后x位加一个字符串，也就是基因，然后可以通过基因去找到分表字段。

### 10 分库分表补充

> ![image-20241025135218108](D:\AppData\Typora\typora-user-images\image-20241025135218108.png)
>
> ![image-20241025135807664](D:\AppData\Typora\typora-user-images\image-20241025135807664.png)
>
> ![image-20241025140548463](D:\AppData\Typora\typora-user-images\image-20241025140548463.png)
>
> ![image-20241025140907784](D:\AppData\Typora\typora-user-images\image-20241025140907784.png)
>
> ![image-20241025141344663](D:\AppData\Typora\typora-user-images\image-20241025141344663.png)
>
> ![image-20241025141423122](D:\AppData\Typora\typora-user-images\image-20241025141423122.png)
